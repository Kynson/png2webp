pub mod error;

use wasm_bindgen::prelude::wasm_bindgen;

use image::{ DynamicImage, ImageOutputFormat };
use image::codecs::png::PngDecoder;

use std::io::Cursor;

use error::ConversionError;

#[wasm_bindgen]
// Errors in this function will be handled by JS
pub fn png2webp(png_data: &[u8]) -> Result<Vec<u8>, ConversionError> {
  let png_decoder = PngDecoder::new(png_data)?;

  let dynamic_png = DynamicImage::from_decoder(png_decoder)?;

  // Pre-allocated memory for header
  // Reference: https://www.iana.org/assignments/media-types/image/webp
  let mut webp_data = Cursor::new(vec![0u8; 15]);
  // This will construct a WebP image using WebP encoder and write the result into webp_data
  // Note that the source PNGs color_type must be L8, La8 Rgb8 or Rgba8
  dynamic_png.write_to(&mut webp_data, ImageOutputFormat::WebP)?;

  Ok(webp_data.into_inner())
}

#[cfg(test)]
mod tests {
  use wasm_bindgen_test::*;
  wasm_bindgen_test::wasm_bindgen_test_configure!(run_in_browser);

  use crate::{ png2webp, ConversionError };

  const PNG_DATA: &[u8] = &[
    0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D,
    0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x08, 0x10, 0x00, 0x00, 0x00, 0x01,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x45, 0xC1, 0xF2, 0xB7, 0x00, 0x00, 0x00,
    0x0A, 0x49, 0x44, 0x41, 0x54, 0x78, 0x01, 0x63, 0x18, 0x05, 0x00, 0x01,
    0x03, 0x00, 0x01, 0x45, 0x41, 0x03, 0xB5, 0x00, 0x00, 0x00, 0x00, 0x49,
    0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82
  ];

  const MALFORMED_PNG_DATA: &[u8] = &[
    0x80, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D,
    0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x08, 0x10, 0x00, 0x00, 0x00, 0x01,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x45, 0xC1, 0xF2, 0xB7, 0x00, 0x00, 0x00,
    0x0A, 0x49, 0x44, 0x41, 0x54, 0x78, 0x01, 0x63, 0x18, 0x05, 0x00, 0x01,
    0x03, 0x00, 0x01, 0x45, 0x41, 0x03, 0xB5, 0x00, 0x00, 0x00, 0x00, 0x49,
    0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x81
  ];

  const EXPECTED_WEBP_DATA: &[u8] = &[
    0x52, 0x49, 0x46, 0x46, 0x46, 0x00, 0x00, 0x00, 0x57, 0x45, 0x42, 0x50,
    0x56, 0x50, 0x38, 0x4c, 0x3a, 0x00, 0x00, 0x00, 0x2f, 0x0f, 0x08, 0x00,
    0x00, 0xcd, 0x55, 0x20, 0x22, 0x02, 0x1e, 0x48, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xa0, 0x88, 0x48, 0x1d, 0x00, 0x00
  ];

  #[wasm_bindgen_test]
  fn valid_png() {
    assert_eq!(png2webp(PNG_DATA), Ok(EXPECTED_WEBP_DATA.into()));
  }

  #[wasm_bindgen_test]
  fn invalid_png() {
    assert_eq!(
      png2webp(MALFORMED_PNG_DATA),
      Err(ConversionError::Decoding("Format error decoding Png: Invalid PNG signature.".to_string()))
    );
  }
}